window.AdventureGlobalVars = window.AdventureGlobalVars || {}; 

// Inicialització robusta de l'estat compartit
if (typeof State === 'undefined') {
    window.State = { 
        variables: window.AdventureGlobalVars // REFERÈNCIA DIRECTA, NO CÒPIA
    };
} else if (typeof State.variables === 'undefined') {
    State.variables = window.AdventureGlobalVars;
} else {
    // Si estem a SugarCube, sincronitzem inicialment
    Object.assign(window.AdventureGlobalVars, State.variables);
}

// Helpers globals per assegurar lectura/escriptura unificada
function getGameVar(name) {
    // Elimina el $ si hi és
    const key = name.startsWith('$') ? name.substring(1) : name;
    if (typeof State !== 'undefined' && State.variables) {
        return State.variables[key];
    }
    return window.AdventureGlobalVars[key];
}

function setGameVar(name, value) {
    const key = name.startsWith('$') ? name.substring(1) : name;
    
    // Escrivim a tot arreu per assegurar sincronització
    window.AdventureGlobalVars[key] = value;
    if (typeof State !== 'undefined' && State.variables) {
        State.variables[key] = value;
    }
    
    // Notifiquem canvi
    if (window.jQuery) jQuery(document).trigger('adventure:state-update');
    console.log(`UPDATED VAR: ${key} = ${value}`);
}


// =================================================================
// ADVENTURE ENGINE (DIÀLEGS)
// =================================================================

window.AdventureEngine = (function() {
    let state = { nodes: [], characters: [], visited: new Set(), currentNodeId: null, containerId: 'dialogue-container' };

    function getCharacter(id) { return state.characters.find(c => c.id === id) || { name: '?', color: '#ccc' }; }
    
    function interpolateText(text) {
        if (!text) return "";
        return text.replace(/\{(\w+)\}/g, (_, v) => {
            const val = getGameVar(v);
            return (val !== undefined && val !== null) ? val : '';
        }).replace(/\$(\w+)/g, (_, v) => {
            const val = getGameVar(v);
            return (val !== undefined && val !== null) ? val : '';
        });
    }

    function evaluate(code) { 
        if (!code || !code.trim()) return true; 
        try { 
            // Construïm un context amb les variables actuals del joc
            const currentVars = (typeof State !== 'undefined' && State.variables) ? State.variables : window.AdventureGlobalVars;
            const keys = Object.keys(currentVars); 
            const values = Object.values(currentVars); 
            
            // FIX: Regex millorada per NO trencar >=, <= o !=
            // Només substitueix "=" per "==" si no té <, >, ! o = al davant.
            const safeCode = code.replace(/(^|[^<>!=])=([^=])/g, '$1==$2');
            
            const fn = new Function(...keys, `return ${safeCode};`); 
            return fn(...values); 
        } catch (e) { 
            console.error("AdventureEngine: Error condició:", code, e); 
            return false; 
        } 
    }
    
    function execute(code) { 
        if (!code || !code.trim()) return; 
        try { 
            const currentVars = (typeof State !== 'undefined' && State.variables) ? State.variables : window.AdventureGlobalVars;
            const keys = Object.keys(currentVars); 
            const values = Object.values(currentVars); 
            
            const parts = code.split(';');
            parts.forEach(part => {
                if(part.includes('=')) {
                    let [left, right] = part.split('=').map(s => s.trim());
                    let op = '=';
                    if(left.endsWith('+')) { op = '+='; left = left.slice(0,-1).trim(); }
                    if(left.endsWith('-')) { op = '-='; left = left.slice(0,-1).trim(); }
                    
                    // Avaluar right side
                    let rightVal;
                    try {
                         // Avaluem el valor de la dreta usant les variables actuals
                         const fnVal = new Function(...keys, `return ${right};`);
                         rightVal = fnVal(...values);
                    } catch(e) { rightVal = right; }

                    let currentVal = getGameVar(left) || 0;
                    
                    if (op === '=') setGameVar(left, rightVal);
                    if (op === '+=') setGameVar(left, currentVal + rightVal);
                    if (op === '-=') setGameVar(left, currentVal - rightVal);
                }
            });

        } catch (e) { 
            console.error("AdventureEngine: Error efecte complex (simplificat):", code, e); 
        } 
    }

    function renderNode() {
        const container = document.getElementById(state.containerId);
        if (!container) return;

        const node = state.nodes.find(n => n.id === state.currentNodeId);
        if (!node) { 
            container.innerHTML = ""; 
            container.style.display = 'none'; 
            toggleActive(false); 
            return; 
        }

        const char = getCharacter(node.characterId);
        const textOpts = Array.isArray(node.textOptions) ? node.textOptions : [{ text: node.text || "", condition: "" }];
        let validTexts = textOpts.filter(t => evaluate(t.condition));
        if (validTexts.length === 0 && textOpts.length > 0) validTexts = [textOpts[0]]; 
        const chosenTextObj = validTexts.length > 0 ? validTexts[Math.floor(Math.random() * validTexts.length)] : { text: "..." };
        let finalText = interpolateText(chosenTextObj.text);

        // --- GESTIÓ D'EXPRESSIONS FACIALS ---
        let currentAvatarUrl = char.avatarUrl; // Per defecte: avatar base
        
        // 1. Determinar expressió base del NODE (suportant la llista condicional 'expressionOptions')
        let nodeExpressionName = node.expression || node.Expression || node.characterExpression || node.CharacterExpression;
        
        const exprOpts = node.expressionOptions || node.ExpressionOptions;
        if (exprOpts && Array.isArray(exprOpts)) {
            // Busquem la primera expressió que compleixi la condició
            const validExpr = exprOpts.find(e => evaluate(e.condition));
            
            // FIX: Només sobreescrivim si l'expressió NO és buida. 
            // Això evita que opcions buides com { expression: "", condition: "" } amaguin "Enfadat"
            if (validExpr && validExpr.expression && validExpr.expression.trim() !== "") {
                nodeExpressionName = validExpr.expression;
            }
        }

        // 2. Prioritat: Expressió del text > Expressió del node
        const expressionName = chosenTextObj.expression || 
                               chosenTextObj.Expression || 
                               chosenTextObj.characterExpression || 
                               chosenTextObj.CharacterExpression || 
                               nodeExpressionName;

        if (expressionName && char.expressions && Array.isArray(char.expressions)) {
            // Busquem l'expressió pel nom (ignorant majúscules/minúscules)
            const expressionObj = char.expressions.find(e => e.name.trim().toLowerCase() === expressionName.trim().toLowerCase());
            if (expressionObj && expressionObj.url) {
                currentAvatarUrl = expressionObj.url;
                console.log(`AdventureEngine: Aplicant expressió "${expressionObj.name}" -> ${expressionObj.url}`);
            } else {
                console.warn(`AdventureEngine: Expressió "${expressionName}" no trobada per al personatge ${char.name}`);
            }
        }
        // ------------------------------------

        let html = `
        <div class="adv-dialogue-box" style="border-top-color: ${char.color}">
            <div class="adv-portrait" style="background-color: ${char.color}">
                ${currentAvatarUrl ? `<img src="${currentAvatarUrl}">` : `<span>${char.name[0]}</span>`}
            </div>
            <div class="adv-content">
                <h3 class="adv-name" style="color: ${char.color}">${char.name}</h3>
                <p class="adv-text">${finalText}</p>
                <div class="adv-options">`;

        const availableOptions = node.options.filter((opt, idx) => {
            const visitedKey = node.id + '_' + idx;
            if (opt.once && state.visited.has(visitedKey)) return false;
            if (opt.condition && !evaluate(opt.condition)) return false;
            return true;
        });

        if (availableOptions.length === 0 && node.options.length > 0) { 
            html += `<div class="adv-msg">(No hi ha opcions disponibles)</div>`; 
            html += `<button onclick="AdventureEngine.close()">Tancar</button>`;
        }
        else if (node.options.length === 0) { 
             html += `<button onclick="AdventureEngine.close()">Fi</button>`; 
        }
        else { 
            availableOptions.forEach((opt) => { 
                const idx = node.options.indexOf(opt); 
                html += `<button onclick="AdventureEngine.selectOption('${node.id}', ${idx})">${opt.text}</button>`; 
            }); 
        }
        html += `</div></div></div>`; 
        container.innerHTML = html;
        container.style.display = 'block';
    }

    function toggleActive(isActive) {
        if(isActive) document.documentElement.classList.add('adv-dialogue-active');
        else document.documentElement.classList.remove('adv-dialogue-active');
    }

    return {
        interpolateText: interpolateText,
        init: function(jsonData, containerId = 'dialogue-container') {
            try {
                const data = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;
                const coreData = data.appState || data; 
                state.nodes = coreData.nodes || []; 
                state.characters = coreData.characters || []; 
                state.visited = new Set(); 
                state.containerId = containerId;
                
                const defaultVars = coreData.globalVariables || {};
                for (const key in defaultVars) {
                    if (getGameVar(key) === undefined) {
                        setGameVar(key, defaultVars[key]);
                    }
                }
                
                if (window.jQuery) jQuery(document).trigger('adventure:state-update');

                let container = document.getElementById(containerId);
                if (!container) {
                    container = document.createElement('div');
                    container.id = containerId;
                    document.body.appendChild(container);
                }
                
                container.style.display = 'block';
                if (window.jQuery) jQuery(container).show();

                if (state.nodes.length === 0) return;
                
                state.currentNodeId = state.nodes[0].id;
                toggleActive(true); 
                setTimeout(renderNode, 10);
            } catch (e) { console.error("AdventureEngine Init Error:", e); }
        },
        selectOption: function(nodeId, optionIndex) {
            const node = state.nodes.find(n => n.id === nodeId); const opt = node.options[optionIndex];
            if (opt.once) state.visited.add(nodeId + '_' + optionIndex);
            if (opt.effect) execute(opt.effect);
            
            let nextId = opt.targetNodeId;
            if (opt.altTargetNodeId && opt.targetCondition && evaluate(opt.targetCondition)) nextId = opt.altTargetNodeId;
            
            if (nextId) { 
                state.currentNodeId = nextId; 
                renderNode(); 
            } else { 
                this.close();
            }
        },
        close: function() {
            const container = document.getElementById(state.containerId); 
            if (container) {
                container.innerHTML = ""; 
                container.style.display = 'none';
                if (window.jQuery) jQuery(container).hide();
            }
            toggleActive(false); 
        }
    };
})();

// =================================================================
// GESTIÓ D'ESDEVENIMENTS (JQUERY)
// =================================================================

jQuery(document).ready(function () {

    // Inicialització de variables de comptatge intern
    if (typeof State !== 'undefined' && State.variables) {
        if (State.variables.hotspotClicks === undefined) State.variables.hotspotClicks = {};
    }

    function evaluateCondition(conditionVarName, conditionVal) {
        if (!conditionVarName || conditionVal === undefined || conditionVal === null) return true; 

        const varName = conditionVarName.startsWith('$') ? conditionVarName.substring(1) : conditionVarName;
        const currentValue = getGameVar(varName); // USEM EL HELPER UNIFICAT
        
        let operatorUsed = '==';
        let valuePart = String(conditionVal).trim();
        const operators = ['===', '==', '!==', '!=', '>=', '<=', '>', '<'];
        for (const op of operators) {
            if (valuePart.startsWith(op)) {
                operatorUsed = op;
                valuePart = valuePart.substring(op.length).trim();
                break;
            }
        }
        let parsedVal = valuePart;
        if (valuePart === 'true') parsedVal = true;
        else if (valuePart === 'false') parsedVal = false;
        else if (!isNaN(Number(valuePart)) && valuePart !== '') parsedVal = Number(valuePart);
        
        try { return eval(`${JSON.stringify(currentValue)} ${operatorUsed} ${JSON.stringify(parsedVal)}`); } 
        catch (e) { return false; }
    }

    // --- FUNCIÓ CLAU: VISIBILITAT I CREACIÓ D'IMATGES (ROBUSTA + FADE 2s) ---
    function updateHotspotVisibility() {
        // NOU: Força l'ocultació d'imatges estàtiques que Twine pugui haver injectat
        jQuery('.twine-image-wrapper img:not([usemap]):not(.hotspot-visual)').hide();

        const wrapper = document.querySelector('.twine-image-wrapper');
        const mainImg = wrapper ? wrapper.querySelector('img[usemap]') : null;
        
        if (!wrapper || !mainImg) return;

        const wrapperRect = wrapper.getBoundingClientRect();
        const imgRect = mainImg.getBoundingClientRect();

        const offsetX = imgRect.left - wrapperRect.left;
        const offsetY = imgRect.top - wrapperRect.top;

        let scaleX = 1, scaleY = 1;
        if (mainImg.naturalWidth > 0) {
            scaleX = imgRect.width / mainImg.naturalWidth;
            scaleY = imgRect.height / mainImg.naturalHeight;
        } else {
            mainImg.onload = updateHotspotVisibility;
            return;
        }

        jQuery('.hotspot-item').each(function() {
            const el = jQuery(this);
            const varName = el.data('overlay-condition-var');
            // FIX: Llegir l'operador explícit si existeix
            let val = el.data('overlay-condition-val');
            const op = el.data('overlay-condition-op');
            
            if (op && val !== undefined) {
                val = op + String(val);
            }
            
            const overlayFile = el.data('overlay-filename');
            
            const alt = el.attr('alt') || 'hotspot-' + Math.random().toString(36).substr(2, 9);
            const imgId = 'visual-' + alt.replace(/\s+/g, '-');

            let shouldShow = true;
            if (varName !== undefined) {
                 shouldShow = evaluateCondition(varName, val);
            }

            if (shouldShow) {
                el.show();

                if (overlayFile) {
                    let img = document.getElementById(imgId);
                    
                    if (!img) {
                        img = document.createElement('img');
                        img.id = imgId;
                        img.src = overlayFile;
                        img.className = 'hotspot-visual';
                        // IMPORTANT: No establim display:block forçat, deixem que fadeIn controli
                        img.style.display = 'none'; 
                        jQuery('.twine-image-wrapper').append(img);
                    }
                    
                    const coords = el.attr('coords').split(',').map(Number);
                    if (coords.length === 4) {
                        const [x1, y1, x2, y2] = coords;
                        img.style.left = (x1 * scaleX + offsetX) + 'px';
                        img.style.top = (y1 * scaleY + offsetY) + 'px';
                        img.style.width = ((x2 - x1) * scaleX) + 'px';
                        img.style.height = ((y2 - y1) * scaleY) + 'px';
                    }
                    
                    // Si ja està visible, no fem res. Si està ocult, fem fadeIn.
                    if (!jQuery(img).is(':visible')) {
                        jQuery(img).stop(true, false).fadeIn(2000);
                    }
                }
            } else {
                el.hide();
                const img = document.getElementById(imgId);
                if (img && jQuery(img).is(':visible')) {
                    jQuery(img).stop(true, false).fadeOut(2000);
                }
            }
        });
    }

    jQuery(document).on('adventure:state-update', updateHotspotVisibility);
    jQuery(window).on('resize', updateHotspotVisibility);
    jQuery(window).on('load', updateHotspotVisibility);

    function interpolateHotspotText(text) {
        if (!text) return "";
        return text.replace(/\$(\w+)/g, function(_, varName) {
            const val = getGameVar(varName);
            return (val !== undefined && val !== null) ? val : '';
        });
    }

    function playHotspotSound(soundId) {
        if (!soundId) return;
        const idStr = String(soundId).trim();
        if (!idStr) return;
        if (typeof Chapel !== 'undefined' && Chapel.Audio && Chapel.Audio.track) {
            try { const t = Chapel.Audio.track(idStr); if(t) { t.stop(); t.playWhenPossible(); } } catch(e){}
        }
    }

    function stopHotspotSound(soundId) {
        if (!soundId) return;
        const idStr = String(soundId).trim();
        if (typeof Chapel !== 'undefined' && Chapel.Audio && Chapel.Audio.track) {
            try { const t = Chapel.Audio.track(idStr); if(t) t.stop(); } catch(e){}
        }
    }

    function toggleImageInfo(text) {
        const finalText = interpolateHotspotText(text);
        if (typeof State !== 'undefined' && State.variables) State.variables.tempInfoDisplay = finalText;
        const container = document.getElementById('twineImageInfoDisplay');
        if (container) {
            if (!finalText) { jQuery(container).hide(); }
            else {
                container.innerHTML = finalText;
                jQuery(container).show();
            }
        }
    }

    function executeHotspotSetters(hotspotElement) {
        const el = jQuery(hotspotElement);
        let combinedSetterStatements = el.attr('data-setter') || '';

        // FIX: Si existeix data-setter, donem prioritat. Si no, construïm a partir de data-variable
        if (!combinedSetterStatements) {
            const var1 = el.attr('data-variable') || el.attr('data_variable');
            const val1 = el.attr('data-valor') || el.attr('data_valor');
            if (var1 && val1) {
                 combinedSetterStatements = `${var1} ${val1}`;
            }
        }

        const var2 = el.data('variable-2');
        const val2 = el.data('valor-2');
        if (var2 && val2) {
            const stmt = `${var2} ${val2}`;
            combinedSetterStatements = combinedSetterStatements ? `${combinedSetterStatements}; ${stmt}` : stmt;
        }

        if (!combinedSetterStatements) return;

        const statements = combinedSetterStatements.split(';');
        statements.forEach(stmt => {
            const trimmedStmt = stmt.trim();
            if (!trimmedStmt) return;
            // FIX: Actualitzat regex per acceptar 'to'
            const match = trimmedStmt.match(/^\s*(\$\w+)\s*(=|\+=|-=|\*=|\/=|to)\s*(.*)\s*$/);
            if (!match) return;

            const varName = match[1].substring(1);
            const operator = match[2];
            let valueStr = match[3];

            let value;
            if (!isNaN(Number(valueStr))) value = Number(valueStr);
            else if (valueStr === 'true') value = true;
            else if (valueStr === 'false') value = false;
            else if (valueStr.startsWith('$')) {
                const targetVarName = valueStr.substring(1);
                value = getGameVar(targetVarName);
            } else value = valueStr.replace(/^['"]|['"]$/g, '');

            let currentVal = getGameVar(varName);
            if (currentVal === undefined) currentVal = (typeof value === 'number') ? 0 : "";

            switch (operator) {
                case '=': 
                case 'to': // AFEGIT SUPORT PER 'to'
                    setGameVar(varName, value); break;
                case '+=': setGameVar(varName, currentVal + value); break;
                case '-=': setGameVar(varName, currentVal - value); break;
                case '*=': setGameVar(varName, currentVal * value); break;
                case '/=': if (value !== 0) setGameVar(varName, currentVal / value); break;
            }
        });
        
        updateHotspotVisibility();
    }

    // --- ESDEVENIMENTS MOUSE/CLICK (SEGURS) ---

    jQuery(document).on('mouseenter', '.hotspot-item', function () { 
        if (!jQuery(this).is(':visible')) return; 

        const el = jQuery(this);
        const limit = parseInt(el.data('visit-limit'));
        const id = el.attr('alt');
        
        if (!isNaN(limit) && getGameVar('hotspotClicks') && getGameVar('hotspotClicks')[id] >= limit) {
            toggleImageInfo(el.attr('data-visit-limit-enter'));
            playHotspotSound(el.data('sound-fail'));
            return;
        }

        // FIX: Incloure l'operador explícit si n'hi ha
        let val = el.data('condition-val');
        const op = el.data('condition-op');
        if (op && val !== undefined) val = op + String(val);

        if (evaluateCondition(el.data('condition-var'), val)) {
            toggleImageInfo(el.attr('data_info'));
            playHotspotSound(el.data('sound'));
        } else {
            toggleImageInfo(el.attr('text_fail_enter'));
            playHotspotSound(el.data('sound-fail'));
        }
    });

    jQuery(document).on('mouseleave', '.hotspot-item', function () { 
        toggleImageInfo('');
        stopHotspotSound(jQuery(this).data('sound'));
        stopHotspotSound(jQuery(this).data('sound-fail'));
    });

    jQuery(document).on('click', 'area.hotspot-item[data-action="dialog"]', function (e) {
        e.preventDefault(); 
        if (!jQuery(this).is(':visible')) return; 

        const el = jQuery(this);
        const id = el.attr('alt');
        
        let targetId = el.data('target');
        const dialogId = el.data('dialog-id');
        const charId = el.data('character');

        if (!targetId) {
            const searchId = dialogId || charId;
            if (searchId) {
                if (document.getElementById(searchId)) targetId = searchId;
                else targetId = 'dialogue-data-' + searchId;
            }
        }

        const limit = parseInt(el.data('visit-limit'));
        let clicks = getGameVar('hotspotClicks') || {};
        if (!getGameVar('hotspotClicks')) setGameVar('hotspotClicks', clicks);

        if (!isNaN(limit) && clicks[id] >= limit) {
            toggleImageInfo(el.attr('data-visit-limit-clic'));
            playHotspotSound(el.data('sound-click-fail'));
            return;
        }

        // FIX: Incloure l'operador explícit si n'hi ha
        let val = el.data('condition-val');
        const op = el.data('condition-op');
        if (op && val !== undefined) val = op + String(val);

        if (!evaluateCondition(el.data('condition-var'), val)) {
            toggleImageInfo(el.attr('text_fail_clic'));
            playHotspotSound(el.data('sound-click-fail'));
            return;
        }

        executeHotspotSetters(this);
        if (!isNaN(limit)) {
            clicks[id] = (clicks[id] || 0) + 1;
            setGameVar('hotspotClicks', clicks);
        }
        playHotspotSound(el.data('sound-click'));
        
        const info2 = el.attr('data_info_2');
        if (info2) {
             toggleImageInfo(info2);
        } else {
             toggleImageInfo(el.attr('data_info'));
        }

        if (targetId) {
            const scriptEl = document.getElementById(targetId);
            if (scriptEl && scriptEl.innerHTML) {
                if (window.AdventureEngine) {
                    window.AdventureEngine.init(scriptEl.innerHTML);
                }
            }
        }
    });

    jQuery(document).on('click', 'area.hotspot-item[data-passage]', function (e) {
        e.preventDefault();
        if (!jQuery(this).is(':visible')) return; 

        const el = jQuery(this);
        const passage = el.data('passage');
        
        // FIX: Incloure l'operador explícit si n'hi ha
        let val = el.data('condition-val');
        const op = el.data('condition-op');
        if (op && val !== undefined) val = op + String(val);

        if (evaluateCondition(el.data('condition-var'), val)) {
            executeHotspotSetters(this);
            playHotspotSound(el.data('sound-click'));
            
            const info2 = el.attr('data_info_2');
            if (info2) {
                toggleImageInfo(info2);
            } else {
                toggleImageInfo(el.attr('data_info'));
            }
            
            const link = jQuery("tw-link").filter((i,e) => jQuery(e).text().trim().toLowerCase() === passage.trim().toLowerCase());
            if (link.length) link.click();
        } else {
            toggleImageInfo(el.attr('text_fail_clic'));
            playHotspotSound(el.data('sound-click-fail'));
        }
    });
    
    jQuery(document).on('click', 'area.hotspot-item[data-setter]:not([data-passage]):not([data-action="dialog"])', function (e) {
        e.preventDefault();
        if (!jQuery(this).is(':visible')) return; 

        const el = jQuery(this);
        const id = el.attr('alt');
        const limit = parseInt(el.data('visit-limit'));

        let clicks = getGameVar('hotspotClicks') || {};
        if (!getGameVar('hotspotClicks')) setGameVar('hotspotClicks', clicks);

        if (!isNaN(limit) && clicks[id] >= limit) {
             toggleImageInfo(el.attr('data-visit-limit-clic'));
             playHotspotSound(el.data('sound-click-fail'));
             return;
        }

        // FIX: Incloure l'operador explícit si n'hi ha
        let val = el.data('condition-val');
        const op = el.data('condition-op');
        if (op && val !== undefined) val = op + String(val);

        if (evaluateCondition(el.data('condition-var'), val)) {
            executeHotspotSetters(this);
            if (!isNaN(limit)) {
                clicks[id] = (clicks[id] || 0) + 1;
                setGameVar('hotspotClicks', clicks);
            }
            
            playHotspotSound(el.data('sound-click'));
            
            const info2 = el.attr('data_info_2');
            toggleImageInfo(info2 ? info2 : el.attr('data_info'));
        } else {
            toggleImageInfo(el.attr('text_fail_clic'));
            playHotspotSound(el.data('sound-click-fail'));
        }
    });

    updateHotspotVisibility();
});
